<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>GRID</title>
    <style>
        body {
            background: #2e2d35;
        }

        svg {
            width: 100vw;
            height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
        }

        .flashlight {
            --opacity-multiplier: 0;
        }

        .letters {
            font-family: monospace;
            letter-spacing: var(--spacing-x);
            white-space: break-spaces;
            transform: translate(var(--spacing-x), var(--spacing-y));
            dominant-baseline: hanging;
        }

        #lettersBackdrop {
            fill: black;
        }

        #lettersContent {
            fill: rgb(255, 242, 211);
            filter: url(#glow);
        }
    </style>
</head>

<body>
    <svg>
        <defs>
            <mask id="lettersMask">
                <rect width="100%" height="100%" style="fill: white" />
                <g id="lettersBackdrop" class="letters"></g>
            </mask>
            <radialGradient id="flashlightGradient" cx="0.5" cy="0.5" r="0.5">
                <stop offset="0%" stop-color="rgba(255, 239, 202, 1)" />
                <stop offset="10%" stop-color="rgba(255, 239, 202, 1)" />
                <stop offset="25%" stop-color="rgba(249, 220, 144, 0.4)" />
                <stop offset="100%" stop-color="transparent" />
            </radialGradient>
            <filter id="glow">
                <feGaussianBlur stdDeviation="1.5" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
        </defs>
        <rect class="flashlight" width="1200px" height="1200px" fill="url(#flashlightGradient)"
            style="opacity: calc(var(--opacity-multiplier) * 0.7)"></rect>
        <rect width="100%" height="100%" fill="#171a2b" mask="url(#lettersMask)" />
        <g id="lettersContent" class="letters"></g>
        <rect class="flashlight" width="1200px" height="1200px" fill="url(#flashlightGradient)"
            style="opacity: calc(var(--opacity-multiplier) * 0.05)"></rect>
    </svg>


    <script>
        const letterSize = 30;
        const xScale = 1.816;
        const yScale = 1.34;


        function initialize() {
            window.addEventListener('resize', renderGrid);
            window.addEventListener('mousemove', (e) => {
                const deadzone = 0.005;
                const margin = 0.04;
                const maxOpacity = 0.5;
                let windowSize = { width: window.innerWidth, height: window.innerHeight };
                let flashlights = document.getElementsByClassName('flashlight');
                for (let f of flashlights) {
                    f.setAttribute('x', e.clientX - 600);
                    f.setAttribute('y', e.clientY - 600);
                    let posX = e.clientX / windowSize.width;
                    let posY = e.clientY / windowSize.height;

                    let newOpacity = Math.max(0, Math.min(1, (posX - deadzone) / (margin - deadzone), (posY - deadzone) / (margin - deadzone), (1 - posX - deadzone) / (margin - deadzone), (1 - posY - deadzone) / (margin - deadzone)));
                    f.style.setProperty('--opacity-multiplier', newOpacity);
                }
            });
            renderGrid();
        }
        initialize();

        function renderGrid() {
            let mx = Math.floor(window.innerWidth / (letterSize / xScale) / 1.7);
            let my = Math.floor(window.innerHeight / (letterSize / yScale) / 1.7);

            var _words = []
            for (let i = 0; i < 100; i++) _words.push("WORD");
            let grid = fillGrid(mx, my, _words)

            function randomCharacter() {
                let alphabet = 'ABCDEFGHIJKLMNOPRSTUVWXYZ#%:+1234567890';
                return alphabet[Math.floor(Math.random() * alphabet.length)];
            }
            injectGridHtml(document.getElementById('lettersBackdrop'), grid, randomCharacter);
            injectGridHtml(document.getElementById('lettersContent'), grid, ()=>" ");
        }

        function injectGridHtml(container, wordGrid, fillerFunc) {
            let html = '';
            for (var y = 0; y < wordGrid["my"]; y++) {
                let text = '';
                for (var x = 0; x < wordGrid["mx"]; x++) {
                    let letter 
                    if (wordGrid[`${x}:${y}`]) letter = wordGrid[`${x}:${y}`];
                    else letter = fillerFunc();

                    if (letter == " ") letter = "&nbsp;";
                    text += letter;
                }
                html += `<text x=0 style="transform: translate(0, calc(${letterSize/yScale*y}px + var(--spacing-y) * ${y}))">${text}</text>`;
            }

            container.innerHTML = html;
            container.style.setProperty('font-size', `${letterSize}px`);
            container.style.setProperty('line-height', `calc(${letterSize/yScale}px + var(--spacing-y))`);
            container.style.setProperty('--spacing-x', `calc((100vw - ${wordGrid["mx"] * letterSize / xScale}px)/${wordGrid["mx"] + 1})`);
            container.style.setProperty('--spacing-y', `calc((100vh - ${wordGrid["my"] * letterSize / yScale}px)/${wordGrid["my"] + 1})`);
        }

        function fillGrid(mx, my, words) {
            let grid = {mx, my};
            let horizontal = true;
            for (let word of words) {
                let mi, si // Main and secondary axis
                let generatePos = () => {
                    mi = Math.floor(1 + Math.random() * ((horizontal ? mx : my) - word.length - 1));
                    si = Math.floor(1 + Math.random() * ((horizontal ? my : mx) - 2));
                }
                let posToKey = (offset, suboffset=0) => {
                    return horizontal ? `${mi + offset}:${si + suboffset}` : `${si + suboffset}:${mi + offset}`;
                }

                let isPosValid = () => {
                    if (grid[posToKey(-1)] || grid[posToKey(word.length)]) return false;
                    let overlap = true;
                    for (let i = 0; i < word.length; i++) {
                        if (grid[posToKey(i)] && grid[posToKey(i)] != word[i]) return false;
                        if (!grid[posToKey(i)]) for (let j of [-1, 1]) if (grid[posToKey(i, j)]) return false;
                        if (!grid[posToKey(i)]) overlap = false;
                    }
                    if (overlap) return false;
                    return true;
                }

                let maxTries = 1E4;
                do { generatePos(); } while (!isPosValid() && maxTries-- > 0);
                if (maxTries <= 0) continue;

                for (let i = 0; i < word.length; i++) grid[posToKey(i)] = word[i];
                horizontal = !horizontal;
            }
            return grid;
        }
    </script>
</body>

</html>